<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PurplePlatform - Synthetic Trading</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <link rel="stylesheet" href="./styles/style.css" />
  <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
<script src="https://unpkg.com/brain.js@2.0.0-beta.2/dist/brain-browser.min.js"></script>
</head>
<body>

  <!-- Top App Bar -->
  <header class="app-bar">
    <div class="app-title">üü£ PurplePlatform</div>
    <div class="app-actions">
      <button aria-label="Toggle Theme" id="themeToggle"><span class="material-icons">light_mode</span></button>
      <button><img src="https://i.pravatar.cc/40" class="mini-avatar" alt="Avatar"></button>
    </div>
  </header>

  <!-- User Info Header -->
  <section class="user-header">
    <div class="user-profile">
      <img src="https://i.pravatar.cc/100" alt="Profile" class="profile-pic" />
      <div class="user-meta">
        <div class="user-name">John Doe</div>
        <div class="user-id">Account: CR1234567</div>
        <div class="user-email">john@example.com</div>
      </div>
    </div>
    <div class="balance-box">
      <span>Balance:</span> <strong id="acct-bal">$10,000.00</strong>
    </div>
  </section>

  <!-- Chart Area -->
  <main>
    <section id="chart-section">
      <div id="chart"></div>
    </section>
  </main>

  <!-- Risk Amount Input (hidden by default) -->
  <div class="risk-entry hidden" id="risk-entry">
    <label for="risk-amount">Risk Amount:</label>
    <input type="number" id="risk-amount" placeholder="0.00" />
  </div>

  <!-- Toast Notification -->
  <div class="toast" id="toast">Trade Executed</div>

  <!-- Floating Action Bar -->
  <footer class="fab-bar">
    <div class="fab-container">
      <button class="fab-nav" title="Home" onclick = "fullScreen(document.getElementById('chart'),0);"><span class="material-icons">home</span></button>
      <button class="fab-nav" title="Chart" onclick = "fullScreen(document.getElementById('chart'),1);"><span class="material-icons">show_chart</span></button>

      <button id="sell-btn" class="fab-extended red hidden">
        <span class="material-icons">call_received</span> Sell
      </button>
      <button id="buy-btn" class="fab-extended green hidden">
        <span class="material-icons">call_made</span> Buy
      </button>

      <button id="main-fab" class="fab-main" aria-label="Trade">
        <span id="fabIcon" class="material-icons">add</span>
      </button>

      <button class="fab-nav" title="History" id = "his-but"><span class="material-icons">history</span></button>
      <button class="fab-nav" title="Bot"><span class="material-icons">smart_toy</span></button>
    </div>
  </footer>

  <!-- Login Card -->
  <div id="login-card" class="login-card hidden">
    <div class="login-content">
        <p class="close-btn" aria-label="Close Login" onclick = "document.getElementById('login-card').classList.add('hidden');">X</p>
      <h3>üîê Sign In To Continue</h3>
      <input type="text" placeholder="Enter API Key" id="api-key" />
      <button id="login-btn">Login</button>
    </div>
  </div>

  <div class="history-container hidden" id = "his-con">
    <h2>üìú Trade History</h2>
    <div class="filter-bar">
      <div class="date-input">
        <label>Start Date</label>
        <input type="date" id="startDate"/>
      </div>
      <div class="date-input">
        <label>End Date</label>
        <input type="date" id="endDate"/>
      </div>
      <button id="applyBtn">Apply</button>
    </div>
    <div id="history-list" class="history-list"></div>
  </div>

  <script>
  (function() {
// ==================== f.js ====================
function sendProposal({ symbol, amount, duration, contract_type }) {
  if (!window.yAuth || window.yAuth.readyState !== 1) return console.warn('yAuth not ready');

  const proposal = {
    proposal: 1,
    amount,
    basis: 'stake',
    contract_type,
    currency: 'USD',
    duration,
    duration_unit: 't',
    symbol,
  };

  window.yAuth.send(JSON.stringify(proposal));
}

function buyContract(proposalId, price = 1) {
  if (!window.yAuth || window.yAuth.readyState !== 1) return;

  window.yAuth.send(JSON.stringify({
    buy: proposalId,
    price,
  }));
}

function sellContract(contractId) {
  if (!window.yAuth || window.yAuth.readyState !== 1) return;

  window.yAuth.send(JSON.stringify({
    sell: contractId,
    price: 0,
  }));
}

function getPortfolio() {
  if (!window.yAuth || window.yAuth.readyState !== 1) return;

  window.yAuth.send(JSON.stringify({ portfolio: 1 }));
}

function cancelAll() {
  if (!window.yAuth || window.yAuth.readyState !== 1) return;

  window.yAuth.send(JSON.stringify({ sell_expired: 1 }));
}

function fullScreen(el, toggle = null, iconEl = null) {
  const isActive = el.dataset.fullscreen === "true";
  toggle = toggle ?? !isActive;
  let overlay = document.getElementById("fullscreen-overlay");

  if (!overlay) {
    overlay = document.createElement("div");
    overlay.id = "fullscreen-overlay";
    Object.assign(overlay.style, {
      position: "fixed",
      top: 0, left: 0,
      width: "100vw",
      height: "100vh",
      background: "rgba(0,0,0,0.6)",
      opacity: 0,
      zIndex: 9998,
      transition: "opacity 0.4s ease",
      pointerEvents: "none"
    });
    document.body.appendChild(overlay);
  }

  if (toggle) {
    const r = el.getBoundingClientRect();
    el.dataset.fullscreen = "true";
    el.dataset.originalStyle = el.getAttribute("style") || "";
    
    document.querySelectorAll("header, section.user-header, .risk-entry, .login-card, .toast, .fab-bar ~ *:not(footer)")
      .forEach(e => e.classList.add("hidden"));

    Object.assign(el.style, {
      transition: "all 0.4s ease",
      transform: "scale(1)",
      position: "fixed",
      top: `${r.top}px`,
      left: `${r.left}px`,
      width: `${r.width}px`,
      height: `${r.height}px`,
      zIndex: 9999,
      background: "#000",
      boxShadow: "0 0 40px rgba(0,0,0,0.6)"
    });

    requestAnimationFrame(() => {
      Object.assign(el.style, {
        top: "0",
        left: "0",
        width: "100vw",
        height: "100vh",
        transform: "scale(1.01)"
      });
      overlay.style.opacity = "1";
    });

    if (iconEl) iconEl.textContent = "fullscreen_exit";
  } else {
    el.dataset.fullscreen = "false";
    el.style.transition = "all 0.4s ease";
    el.style.transform = "scale(0.98)";
    overlay.style.opacity = "0";

    setTimeout(() => {
      const original = el.dataset.originalStyle || "";
      el.removeAttribute("style");
      if (original) el.setAttribute("style", original);
      document.querySelectorAll(".hidden").forEach(e => e.classList.remove("hidden"));
    }, 400);

    if (iconEl) iconEl.textContent = "fullscreen";
  }
}

const showToast = (msg) => {
  const toast = document.getElementById('toast');
  if (!toast) return;
  toast.textContent = msg;
  toast.classList.add('show');
  setTimeout(() => toast.classList.remove('show'), 3000);
};

// ==================== sockets.js ====================
const $ = id => document.getElementById(id);
let yAuth = null;
window.yAuth = yAuth;
const transactions = [];
let loadingInterval;

const getCurrencySymbol = code => ({
  USD: "$", EUR: "‚Ç¨", GBP: "¬£", JPY: "¬•", NGN: "‚Ç¶"
}[code] || code);

function setDetails(details) {
  const $q = sel => document.querySelector(sel);
  const nameEl = $q(".user-name");
  if (nameEl) nameEl.innerHTML = details.fullname || "Unnamed User";
  const emailEl = $q(".user-email");
  if (emailEl) emailEl.innerHTML = details.email || "No Email";
  const idEl = $q(".user-id");
  if (idEl) idEl.innerHTML = `Account: ${details.loginid}`;
  const balanceEl = $q("#acct-bal");
  if (balanceEl) {
    const symbol = getCurrencySymbol(details.currency);
    balanceEl.innerHTML = `${symbol}${(+details.balance).toLocaleString(undefined, { minimumFractionDigits: 2 })}`;
  }
}

function initYAuth(token, appId, button) {
  if (yAuth && yAuth.readyState !== WebSocket.CLOSED) {
    yAuth.close();
  }

  yAuth = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${appId}`);
  window.yAuth = yAuth;

  yAuth.onopen = () => yAuth.send(JSON.stringify({ authorize: token }));

  yAuth.onmessage = ({ data }) => {
    const res = JSON.parse(data);
    const type = res.msg_type;

    if (res.error) {
      stopLoading(button, "Retry");
      showToast("‚ùå Auth Error: " + res.error.message);
      yAuth.close();
      yAuth = null;
      window.yAuth = null;
      return;
    }

    if (type === "authorize") {
      stopLoading(button, "‚úî Success");
      setDetails(res.authorize);
      yAuth.send(JSON.stringify({ balance: 1, subscribe: 1 }));
      yAuth.send(JSON.stringify({ transaction: 1, subscribe: 1 }));
    }

    if (type === "balance") {
      const el = $("acct-bal");
      if (el) {
        const { balance, currency } = res.balance;
        const symbol = getCurrencySymbol(currency);
        el.innerHTML = `${symbol}${(+balance).toLocaleString(undefined, { minimumFractionDigits: 2 })}`;
      }
    }

    if (type === "transaction") {
      transactions.unshift(res.transaction);
      if (transactions.length > 100) transactions.pop();
    }
    
    if (type === 'proposal') {
      yAuth.send(JSON.stringify({
        buy: res.proposal.id,
        price: 1
      }));
    }
  };

  yAuth.onerror = () => stopLoading(button, "Retry");
  yAuth.onclose = () => console.warn("[yAuth] Closed. Will reconnect on next login.");
}

function startLoading(btn, text = "Authorizing") {
  let dots = "";
  loadingInterval = setInterval(() => {
    btn.textContent = text + (dots = dots.length < 3 ? dots + "." : "");
  }, 300);
}

function stopLoading(btn, text = "Login") {
  clearInterval(loadingInterval);
  btn.textContent = text;
  btn.classList.remove("loading");
}

function handleLogin() {
  const apiKeyInput = $("api-key");
  if (!apiKeyInput) return;
  const token = apiKeyInput.value.trim();
  if (!token) return showToast("Please enter your API key.");
  
  const loginBtn = $("login-btn");
  if (!loginBtn) return;
  
  loginBtn.classList.add("loading");
  startLoading(loginBtn);
  initYAuth(token, 1089, loginBtn);
}

window.xAuth = new WebSocket("wss://ws.derivws.com/websockets/v3?app_id=1089");

// ==================== chart.js ====================
class TradingChart {
    static CONFIG = {
        maxCandles: 5000,
        requestCooldown: 500,
        granularity: 60,
        indicatorPeriod: 20,
        volatilityThreshold: 0.015,
        momentumThreshold: 0.008,
        themes: {
            dark: {
                chartOptions: { 
                    layout: { background: { color: 'transparent' }, textColor: '#EEE' },
                    grid: { vertLines: { color: '#2c2c3c' }, horzLines: { color: '#2c2c3c' } },
                    timeScale: { timeVisible: true, secondsVisible: false },
                    crosshair: { mode: 0 }
                },
                seriesOptions: {
                    wickUpColor: '#10B981',
                    upColor: '#10B981',
                    wickDownColor: '#EF4444',
                    downColor: '#EF4444',
                    borderVisible: false
                },
                indicatorColors: {
                    bullishStrong: '#10B981',
                    bullishNeutral: '#059669',
                    bullishWeak: '#065F46',
                    bearishStrong: '#EF4444',
                    bearishNeutral: '#DC2626',
                    bearishWeak: '#7F1D1D',
                    neutral: '#4B5563'
                }
            },
            light: {
                chartOptions: {
                    layout: { 
                        background: { 
                            type: 'vertical-gradient',
                            topColor: '#F9FAFB',
                            bottomColor: 'rgba(249, 250, 251, 0.3)',
                        },
                        textColor: '#1F2937',
                        fontSize: 12,
                        fontFamily: 'Roboto, sans-serif'
                    },
                    grid: {
                        horzLines: { color: '#E5E7EB', style: 2 },
                        vertLines: { visible: false }
                    },
                    priceScale: { 
                        autoScale: true,
                        borderColor: '#D1D5DB',
                        mode: LightweightCharts.PriceScaleMode.Normal
                    },
                    timeScale: {
                        borderColor: '#D1D5DB',
                        rightBarStaysOnScroll: true
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.MagnetOHLC,
                        vertLine: { 
                            width: 1,
                            color: '#6B728066',
                            labelBackgroundColor: '#E5E7EB'
                        },
                        horzLine: { labelVisible: false }
                    },
                    watermark: {
                        visible: true,
                        text: `StepIndex ‚Ä¢ MTW Indicator`,
                        fontSize: 14,
                        color: 'rgba(100, 110, 140, 0.5)',
                        horzAlign: 'right'
                    }
                },
                seriesOptions: {
                    wickUpColor: '#059669',
                    upColor: '#059669',
                    wickDownColor: '#DC2626',
                    downColor: '#DC2626',
                    borderVisible: false
                },
                indicatorColors: {
                    bullishStrong: '#059669',
                    bullishNeutral: '#047857',
                    bullishWeak: '#065F46',
                    bearishStrong: '#DC2626',
                    bearishNeutral: '#B91C1C',
                    bearishWeak: '#7F1D1D',
                    neutral: '#6B7280'
                }
            }
        }
    };

    #socket;
    #chart;
    #candleSeries;
    #indicatorSeries;
    #symbol;
    #loaderElement;
    #chartElement;
    #data = [];
    #indicatorData = [];
    #earliestTime = Math.floor(Date.now() / 1000);
    #isLoading = false;
    #isHistoryFullyLoaded = false;
    #rangeDebounceTimer = null;
    #subscriptionId = null;
    #currentTheme = 'dark';

    constructor(chartElementId, socket, options = {}) {
        this.#chartElement = document.getElementById(chartElementId);
        if (!this.#chartElement) {
            const error = new Error(`Chart container element with ID "${chartElementId}" not found.`);
            console.error(error.message);
            throw error;
        }

        this.#socket = socket;
        this.options = { ...TradingChart.CONFIG, ...options };
        this.#symbol = this.options.symbol;

        if (!this.#symbol) {
            const error = new Error('The "symbol" option is required for the TradingChart.');
            console.error(error.message);
            throw error;
        }

        this.#createLoader();
        this.#initializeChart();
        this.#attachHandlers();

        new ResizeObserver(() => this.#chart.timeScale().fitContent()).observe(this.#chartElement);
    }

    #createLoader() {
        this.#loaderElement = document.createElement('div');
        this.#loaderElement.id = `${this.#chartElement.id}-loader`;
        this.#loaderElement.style.cssText = `
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            border: 4px solid rgba(156, 163, 175, 0.3);
            border-top: 4px solid #6B7280;
            border-radius: 50%;
            width: 40px; height: 40px;
            animation: spin 1s linear infinite; z-index: 10;
            display: none;
        `;
        this.#chartElement.style.position = 'relative';
        this.#chartElement.appendChild(this.#loaderElement);

        const spinnerStyleId = 'trading-chart-spinner-style';
        if (!document.getElementById(spinnerStyleId)) {
            const style = document.createElement('style');
            style.id = spinnerStyleId;
            style.innerHTML = `@keyframes spin {
                0% { transform: translate(-50%, -50%) rotate(0deg); }
                100% { transform: translate(-50%, -50%) rotate(360deg); }
            }`;
            document.head.appendChild(style);
        }
    }

    #initializeChart() {
        const theme = this.options.themes.dark;
        this.#chart = LightweightCharts.createChart(this.#chartElement, theme.chartOptions);
        this.#candleSeries = this.#chart.addCandlestickSeries(theme.seriesOptions);
        
        this.#indicatorSeries = this.#chart.addLineSeries({
            color: 'transparent',
            lineWidth: 2,
            lastValueVisible: false,
            priceLineVisible: false,
            crosshairMarkerVisible: true,
        });
    }

    #attachHandlers() {
        this.#socket.onmessage = this.#handleMessage.bind(this);
        this.#socket.onopen = this.#handleOpen.bind(this);
        this.#socket.onclose = this.#handleClose.bind(this);
        this.#socket.onerror = this.#handleError.bind(this);

        this.#chart.timeScale().subscribeVisibleTimeRangeChange(this.#handleTimeRangeChange.bind(this));
    }

    #handleOpen() {
        console.log('WebSocket connection established.');
        this.#loadHistory();
        this.#subscribeToTicks();
    }

    #handleClose() {
        console.warn('WebSocket connection closed.');
        this.#setLoadingState(false);
    }

    #handleError(err) {
        console.error('WebSocket Error:', err);
        this.#setLoadingState(false);
    }

    #handleMessage(event) {
        try {
            const msg = JSON.parse(event.data);
            if (msg?.error) {
                console.error('API Error:', msg.error.message);
                this.#setLoadingState(false);
                return;
            }

            switch (msg?.msg_type) {
                case 'candles':
                    this.#processCandles(msg.candles, msg.subscription?.id);
                    break;
                case 'tick':
                    if (msg.tick?.symbol === this.#symbol) {
                        this.#updateWithTick(msg.tick);
                    }
                    break;
            }
        } catch (error) {
            console.error('Failed to parse incoming JSON:', error);
            this.#setLoadingState(false);
        }
    }

    #handleTimeRangeChange() {
        if (this.#isLoading || this.#isHistoryFullyLoaded) return;

        const visibleRange = this.#chart.timeScale().getVisibleLogicalRange();
        if (visibleRange !== null && visibleRange.from < 50) {
            clearTimeout(this.#rangeDebounceTimer);
            this.#rangeDebounceTimer = setTimeout(
                () => this.#loadHistory(this.#earliestTime),
                this.options.requestCooldown
            );
        }
    }

    #processCandles(candles, subscriptionId) {
        if (!candles || candles.length === 0) {
            this.#isHistoryFullyLoaded = true;
            this.#setLoadingState(false);
            return;
        }

        this.#earliestTime = Math.min(this.#earliestTime, candles[0].epoch);
        
        const candleMap = new Map(this.#data.map(c => [c.time, c]));
        candles.forEach(c => candleMap.set(c.epoch, { time: c.epoch, ...c }));

        this.#data = Array.from(candleMap.values()).sort((a, b) => a.time - b.time);

        if (this.#data.length > this.options.maxCandles) {
            this.#data = this.#data.slice(-this.options.maxCandles);
        }

        this.#candleSeries.setData(this.#data);
        this.#calculateIndicator(true);

        if (subscriptionId) {
            this.#subscriptionId = subscriptionId;
        }
        this.#setLoadingState(false);
    }

    #updateWithTick(tick) {
        if (typeof tick.quote !== 'number' || this.#data.length === 0) return;

        const time = Math.floor(tick.epoch / this.options.granularity) * this.options.granularity;
        let lastCandle = this.#data[this.#data.length - 1];

        if (lastCandle && lastCandle.time === time) {
            lastCandle.high = Math.max(lastCandle.high, tick.quote);
            lastCandle.low = Math.min(lastCandle.low, tick.quote);
            lastCandle.close = tick.quote;
            this.#candleSeries.update(lastCandle);
        } else {
            const newCandle = {
                time,
                open: lastCandle ? lastCandle.close : tick.quote,
                high: tick.quote,
                low: tick.quote,
                close: tick.quote,
            };
            this.#data.push(newCandle);
            this.#candleSeries.update(newCandle);

            if (this.#data.length > this.options.maxCandles) {
                this.#data.shift();
                if (this.#indicatorData.length > 0) {
                    this.#indicatorData.shift();
                }
            }
        }
        this.#calculateIndicator();
    }

    #calculateIndicator(fullRecalculate = false) {
        const period = this.options.indicatorPeriod;
        const volatilityThreshold = this.options.volatilityThreshold;
        const momentumThreshold = this.options.momentumThreshold;
        
        if (this.#data.length < period) return;

        if (fullRecalculate) {
            this.#indicatorData = new Array(this.#data.length);
        }

        const processPoint = (i) => {
            if (i < period - 1) return null;

            const slice = this.#data.slice(i - period + 1, i + 1);
            const closes = slice.map(c => c.close);
            const sma = closes.reduce((sum, val) => sum + val, 0) / period;
            
            const roc = (closes[period - 1] - closes[0]) / closes[0];
            const momentum = Math.abs(roc) > momentumThreshold 
                ? (roc > 0 ? 'strong' : 'weak') 
                : 'neutral';

            const mean = sma;
            const variance = closes.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / period;
            const stdDev = Math.sqrt(variance);
            const volatility = stdDev / mean > volatilityThreshold ? 'high' : 'low';

            let trend = 'neutral';
            if (i >= period) {
                const prevSlice = this.#data.slice(i - period, i);
                const prevSma = prevSlice.reduce((sum, c) => sum + c.close, 0) / period;
                trend = sma > prevSma ? 'bullish' : 'bearish';
            }

            const lineWidth = volatility === 'high' ? 3 : 1;
            let color;
            const theme = this.options.themes[this.#currentTheme];
            
            switch (`${trend}-${momentum}`) {
                case 'bullish-strong': color = theme.indicatorColors.bullishStrong; break;
                case 'bullish-neutral': color = theme.indicatorColors.bullishNeutral; break;
                case 'bullish-weak': color = theme.indicatorColors.bullishWeak; break;
                case 'bearish-strong': color = theme.indicatorColors.bearishStrong; break;
                case 'bearish-neutral': color = theme.indicatorColors.bearishNeutral; break;
                case 'bearish-weak': color = theme.indicatorColors.bearishWeak; break;
                default: color = theme.indicatorColors.neutral;
            }

            return { 
                time: this.#data[i].time, 
                value: sma,
                color,
                lineWidth
            };
        };

        if (fullRecalculate) {
            for (let i = period - 1; i < this.#data.length; i++) {
                const point = processPoint(i);
                if (point) this.#indicatorData[i] = point;
            }
            const validPoints = this.#indicatorData.filter(p => p);
            this.#indicatorSeries.setData(validPoints);
        } else {
            const i = this.#data.length - 1;
            if (i >= period - 1) {
                const point = processPoint(i);
                if (point) {
                    this.#indicatorData[i] = point;
                    this.#indicatorSeries.update(point);
                }
            }
        }
    }

    #subscribeToTicks() {
        if (this.#socket.readyState !== WebSocket.OPEN) return;
        this.#socket.send(JSON.stringify({ ticks: this.#symbol, subscribe: 1 }));
    }

    #unsubscribeFromTicks() {
        if (this.#subscriptionId && this.#socket.readyState === WebSocket.OPEN) {
            this.#socket.send(JSON.stringify({ forget: this.#subscriptionId }));
            console.log(`Unsubscribed from ${this.#symbol}`);
        }
        this.#subscriptionId = null;
    }

    #loadHistory(end = 'latest') {
        if (this.#isLoading || this.#socket.readyState !== WebSocket.OPEN) return;
        this.#setLoadingState(true);

        this.#socket.send(JSON.stringify({
            ticks_history: this.#symbol,
            style: 'candles',
            adjust_start_time: 1,
            count: 500,
            granularity: this.options.granularity,
            end: end,
        }));
    }

    #setLoadingState(isLoading) {
        this.#isLoading = isLoading;
        this.#loaderElement.style.display = isLoading ? 'block' : 'none';
    }

    setTimeframe(newGranularity) {
        if (this.#isLoading || this.options.granularity === newGranularity) return;

        console.log(`Changing timeframe to ${newGranularity} seconds.`);
        this.#setLoadingState(true);
        this.#unsubscribeFromTicks();

        this.options.granularity = newGranularity;
        this.#data = [];
        this.#indicatorData = [];
        this.#candleSeries.setData([]);
        this.#indicatorSeries.setData([]);
        this.#earliestTime = Math.floor(Date.now() / 1000);
        this.#isHistoryFullyLoaded = false;

        this.#loadHistory();
        this.#subscribeToTicks();
    }
    
    setTheme(themeName) {
        const theme = this.options.themes[themeName];
        if (!theme) {
            console.error(`Theme "${themeName}" not found.`);
            return;
        }
        this.#chart.applyOptions(theme.chartOptions);
        this.#candleSeries.applyOptions(theme.seriesOptions);
        this.#currentTheme = themeName;
    }

    toggleTheme() {
        const newTheme = this.#currentTheme === 'dark' ? 'light' : 'dark';
        this.setTheme(newTheme);
    }

    getChart() {
        return this.#chart;
    }

    destroy() {
        console.log(`Destroying chart for symbol ${this.#symbol}`);
        this.#unsubscribeFromTicks();

        clearTimeout(this.#rangeDebounceTimer);
        this.#socket.onmessage = null;
        this.#socket.onopen = null;
        this.#socket.onerror = null;
        this.#socket.onclose = null;
        this.#chart.timeScale().unsubscribeVisibleTimeRangeChange(this.#handleTimeRangeChange.bind(this));

        this.#chart.remove();
        this.#loaderElement.remove();

        this.#data = [];
        this.#indicatorData = [];
        
        const spinnerStyle = document.getElementById('trading-chart-spinner-style');
        if (spinnerStyle) spinnerStyle.remove();
    }
}

// ==================== historyModel.js ====================
const HistoryModel = (() => {
  const $ = id => document.getElementById(id);
  const listContainer = $('history-list');
  const startInput = $('startDate');
  const endInput = $('endDate');
  const applyBtn = $('applyBtn');

  const show = html => listContainer.innerHTML = html;
  const showLoading = () => show("<p>Loading history...</p>");
  const showError = msg => show(`<p style="color:red;">‚ùå ${msg}</p>`);

  const formatDate = ts => new Date(ts * 1000).toLocaleString();

  const render = txns => {
    if (!txns.length) return show("<p>No trades found in this period.</p>");
    const cards = txns.map(tx => `
      <div class="history-card">
        <div class="history-info">
          <div class="history-title">${tx.description}</div>
          <div class="history-desc">Contract ID: ${tx.contract_id || 'N/A'}</div>
        </div>
        <div class="history-meta">
          <div>${formatDate(tx.transaction_time || tx.date)}</div>
          <div style="color:${tx.amount < 0 ? '#d32f2f' : '#388e3c'}">
            ${tx.amount < 0 ? '-' : '+'} $${Math.abs(tx.amount).toFixed(2)}
          </div>
        </div>
      </div>
    `).join('');
    show(cards);
  };

  const fetchStatement = (from, to) => new Promise((resolve, reject) => {
    if (!yAuth || yAuth.readyState !== 1)
      return reject("WebSocket not authorized or not ready.");

    const req = {
      statement: 1,
      limit: 100,
      offset: 0,
      date_from: from,
      date_to: to,
      description: 1
    };

    const listener = ({ data }) => {
      const res = JSON.parse(data);
      if (res.msg_type === 'statement') {
        yAuth.removeEventListener('message', listener);
        resolve(res.statement.transactions || []);
      } else if (res.error) {
        yAuth.removeEventListener('message', listener);
        reject(res.error.message);
      }
    };

    yAuth.addEventListener('message', listener);
    yAuth.send(JSON.stringify(req));
  });

  const load = async (fromDate, toDate) => {
    showLoading();
    const from = Math.floor(new Date(fromDate).getTime() / 1000);
    const to = Math.floor(new Date(toDate).getTime() / 1000);
    try {
      const data = await fetchStatement(from, to);
      render(data);
    } catch (err) {
      showError(err);
    }
  };

  const loadLastWeek = () => {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    const weekAgo = new Date();
    weekAgo.setDate(tomorrow.getDate() - 7);
    const fromStr = weekAgo.toISOString().split("T")[0];
    const toStr = tomorrow.toISOString().split("T")[0];
    startInput.value = fromStr;
    endInput.value = toStr;
    load(fromStr, toStr);
  };

  const attachHandlers = () => {
    applyBtn?.addEventListener("click", () => {
      const from = startInput.value;
      const to = endInput.value;
      if (!from || !to || new Date(from) > new Date(to)) {
        showError("‚ö†Ô∏è Invalid date range.");
      } else {
        load(from, to);
      }
    });
  };

  return {
    init: () => {
      attachHandlers();
      const waitUntilAuth = setInterval(() => {
        if (yAuth && yAuth.readyState === 1) {
          clearInterval(waitUntilAuth);
          loadLastWeek();
        }
      }, 500);
    },
    load,
    loadLastWeek
  };
})();

// ==================== main.js ====================
document.addEventListener('DOMContentLoaded', function() {
    const chart = new TradingChart('chart', window.xAuth, { symbol: 'stpRNG' });
    window.chartView = chart;
    window.addEventListener('beforeunload', () => chart.destroy());

    const $ = id => document.getElementById(id);
    const fab = $('main-fab'), fabIcon = $('fabIcon');
    const buyBtn = $('buy-btn'), sellBtn = $('sell-btn'), risk = $('risk-entry');
    const themeToggle = $('themeToggle');

    fab.onclick = () => {
        if(!window.yAuth){
            showToast("Trading Not Allowed");
            $('login-card').classList.remove('hidden');
            return;
        }
        const open = !buyBtn.classList.contains('hidden');
        [buyBtn, sellBtn, risk].forEach(el => {
            el.classList.toggle('hidden');
            setTimeout(() => el.classList.toggle('visible', !open), 10);
        });
        fabIcon.textContent = open ? 'add' : 'remove';
    };

    const historyBtn = document.getElementById("his-but");
    const historyContainer = document.getElementById("his-con");
    if (historyBtn && historyContainer) {
        const closeHistoryBtn = document.createElement("div");
        closeHistoryBtn.className = "close-btn";
        closeHistoryBtn.innerHTML = "X";
        closeHistoryBtn.onclick = () => {
            historyContainer.classList.remove("graceful-entry");
            historyContainer.classList.add("graceful-exit");
            fullScreen(historyContainer, false);
            setTimeout(() => {
                historyContainer.classList.add("hidden");
                historyContainer.classList.remove("graceful-exit");
            }, 600);
        };
        historyContainer.prepend(closeHistoryBtn);

        historyBtn.addEventListener("click", () => {
            historyContainer.classList.remove("hidden", "graceful-exit");
            historyContainer.classList.add("graceful-entry");
            setTimeout(() => {
                fullScreen(historyContainer, true);
                HistoryModel.init();
            }, 10);
        });
    }

    themeToggle.onclick = () => {
        document.body.classList.toggle('light-theme');
        chart.toggleTheme();
    };

    const loginBtn = $('login-btn');
    if (loginBtn) {
        loginBtn.addEventListener('click', handleLogin);
    }
});

})();
  </script>
<script>
     function fullScreen(el, toggle = null, iconEl = null) {
  const isActive = el.dataset.fullscreen === "true";
  toggle = toggle ?? !isActive;

  let overlay = document.getElementById("fullscreen-overlay");
  if (!overlay) {
    overlay = document.createElement("div");
    overlay.id = "fullscreen-overlay";
    Object.assign(overlay.style, {
      position: "fixed",
      top: 0,
      left: 0,
      width: "100vw",
      height: "100vh",
      background: "rgba(0,0,0,0.6)",
      opacity: 0,
      zIndex: 9998,
      transition: "opacity 0.6s ease",
      pointerEvents: "none",
    });
    document.body.appendChild(overlay);
  }

  if (toggle) {
    const r = el.getBoundingClientRect();
    el.dataset.fullscreen = "true";
    el.dataset.originalStyle = el.style.cssText || "";

    // Hide other UI except footer
    document.querySelectorAll(".fullscreen-hide").forEach(e => {
      if (e.classList.contains("hidden")) {
        e.dataset.hiddenBefore = "true";
      } else {
        e.dataset.hiddenBefore = "false";
        e.classList.add("hidden");
      }
    });

    document.body.style.overflow = "hidden";

    Object.assign(el.style, {
      transition: "all 0.6s ease",
      transform: "scale(1)",
      position: "fixed",
      top: `${r.top}px`,
      left: `${r.left}px`,
      width: `${r.width}px`,
      height: `${r.height}px`,
      zIndex: 9999,
      background: "#000",
      boxShadow: "0 0 40px rgba(0,0,0,0.6)",
      display: "flex",
      flexDirection: "column",
      alignItems: "stretch",
    });

    requestAnimationFrame(() => {
      Object.assign(el.style, {
        top: "0",
        left: "0",
        width: "100vw",
        height: "100vh",
        transform: "scale(1.01)",
      });
      overlay.style.opacity = "1";

      setTimeout(() => {
        const chart = window.chartView?.getChart?.();
        const chartDiv = el.querySelector("#chart");
        if (chart && chartDiv) {
          chart.resize(chartDiv.clientWidth, chartDiv.clientHeight);
        }
      }, 650);
    });

    if (iconEl) iconEl.textContent = "fullscreen_exit";
  } else {
    el.dataset.fullscreen = "false";
    el.style.transition = "all 0.6s ease";
    el.style.transform = "scale(0.98)";
    overlay.style.opacity = "0";

    setTimeout(() => {
      el.style.cssText = el.dataset.originalStyle || "";

      document.querySelectorAll(".fullscreen-hide").forEach(e => {
        if (e.dataset.hiddenBefore === "false") {
          e.classList.remove("hidden");
        }
        delete e.dataset.hiddenBefore;
      });

      document.body.style.overflow = "";

      const chart = window.chartView?.getChart?.();
      const chartDiv = el.querySelector("#chart");
      if (chart && chartDiv) {
        chart.resize(chartDiv.clientWidth, chartDiv.clientHeight);
      }
    }, 600);

    if (iconEl) iconEl.textContent = "fullscreen";
  }
}

 </script>
 </body>
      </html>
          
